---
title: "02_corpus_preparation"
format: md
editor: visual
---

## Corpus preparation for rhyme analysis

## Load pckg

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(tidytext)

# library(udpipe)
# ru_taiga <- udpipe_load_model("../../data/russian-taiga-ud-2.5-191206.udpipe")
```

## Load data

The data tables are resulting from the poem parced with `RhymeTagger`, see the code in: `00_1_rhymetagger_pos.ipynb`. The output is in three columns: `poem_id`, `rhyme_word`, `rhymes` (for the rhyme id/position).

### Corpus-1835 rhymes

```{r}
rhymes_1835 <- read.csv("../../data/ch5/corpus-35_rhymes.csv") %>% select(-X) %>% 
  mutate(id = str_remove(poem_id, "\\.txt$"), # remove .txt for cleaner ids
         id = paste0("M__", id)) # add a letter for "marginals" corpus

glimpse(rhymes_1835)
```

### RNC rhymes

```{r}
# dat <- read.csv("../../../../23_rhymes/parsed_rhymes.csv") # old parsed rhymes from ../23_rhymes (earlier experiment)
# glimpse(dat)
# 
# rnc <- dat %>% 
#   filter(str_detect(poem_id, "^RNC_")) %>% 
#   select(-X)
# 
# head(rnc)
# rnc$poem_id[1:10]
# 
# write.csv(rnc, file = "../../data/ch5/rnc_rhymes.csv")
```

```{r}
# load already parsed data
rnc_rhymes <- read.csv("../../data/ch5/rnc_rhymes.csv") %>% select(-X)

glimpse(rnc_rhymes)

rnc_rhymes %>% 
  mutate(poem_id = str_replace(poem_id, "RNC_", "RNC__")) %>% 
  separate(poem_id, into = c("corpus", "id"), sep = "__") %>% 
  separate(id, into = c("id", "year"), sep = "_") 
```

## Extract rhyme pairs

Create rhyme pairs from 'rhymes' column in annotation

```{r}
rhymes_1835_t <- rhymes_1835 %>% 
  group_by(id, rhymes) %>% 
  mutate(rhyme_pair = ifelse(!is.na(rhymes), # remove NA from collapsing
                             paste0(rhyme_words, collapse = " "), 
                             NA)) %>% 
  ungroup() %>% 
  select(-rhyme_words) %>% 
  distinct() %>% 
  filter(!is.na(rhyme_pair))

rhymes_1835_t %>% 
  sample_n(10)

rhymes_1835_t %>% 
  filter(is.na(rhyme_pair))
```

### long sequences

When rhyme seq is longer than 2 words, separate sequences into consequetive pairs

```{r}
sequencies_full <- rhymes_1835_t %>% 
    filter(str_detect(rhyme_pair, "^\\w+\\s\\w+\\s\\w+.*?")) 

# head(sequencies_full)
# nrow(sequencies_full)

sequencies <- sequencies_full %>% 
    select(rhyme_pair, poem_id) %>% 
    distinct()

head(sequencies)
nrow(sequencies)
```

Loop for rewrite the seq into pairs

```{r}
x <- do.call(rbind,
        apply(sequencies, 1, function(i){
            x <- unlist(strsplit(i[1], " "))
            cbind.data.frame(
              from = x[1:length(x) - 1],
              to = x[2:(length(x))],
              id = i[2]
                )
          })
        )

head(as_tibble(x))
print(paste("Number of rhyme pairs (non-unique) from sequences:", nrow(x)))
```

Extract table with all unique words & their POS+features

```{r}
glimpse(rhymes_1835)

pos_tags <- rhymes_1835 %>% 
  select(rhyme_words, pos) %>% 
  distinct() %>% 
  rename(feats = pos) %>% 
  mutate(pos = str_extract(feats, "^\\w+(,|=)"),
         pos = str_remove(pos, ',|=')) 

head(pos_tags)

```

Add POS tags

```{r}
seq_fin <- as_tibble(x) %>% 
  # attach POS tag to 'from' word
  left_join(pos_tags %>% 
              rename(from = rhyme_words,
                     from_pos = pos,
                     from_feats = feats),
            by = "from") %>% 
  # attach POS tag to 'to' word
  left_join(pos_tags %>% 
              rename(to = rhyme_words, 
                     to_pos = pos,
                     to_feats = feats)) %>% 
  # paste rhyme bigram in a separate column
  mutate(rhyme_pair = paste(from, to), 
         id = paste0("M__", id),
         id = str_remove(id, "\\.txt")) 

# head(seq_fin)
# nrow(seq_fin)

rm(sequencies, sequencies_full, x)
```

### orphan rhymes

```{r}
rhymes_1835_t %>% 
  filter(str_detect(rhyme_pair, "^\\w+$")) %>% head()

print(paste0("Number of orhpan rhyme words (rows with only 1 word in a 'pair') : ", 
             rhymes_1835_t %>% 
    filter(str_detect(rhyme_pair, "^\\w+$")) %>% nrow,
    " out of ", rhymes_1835_t %>% nrow(),
    " rows")
    )
```

### true rhyme pairs

Select true rhyme pairs & add POS

```{r}
rhymes_1835_t <- rhymes_1835_t %>% 
    # remove sequencies
    filter(!str_detect(rhyme_pair, "^\\w+\\s\\w+\\s\\w+.*?")) %>% 
    # remove orphan rhymes
    filter(!str_detect(rhyme_pair, "^\\w+$")) %>%

    mutate(ft = rhyme_pair) %>% 
    separate(ft, c("from", "to"), sep = " ") %>% 
  
    # attach POS tag to 'from' word
    left_join(pos_tags %>% rename(from = rhyme_words,
                                 from_pos = pos,
                                 from_feats = feats),
             by = "from") %>% 
    
    # attach POS tag to `to` word
    left_join(pos_tags %>% rename(to = rhyme_words,
                                 to_pos = pos,
                                 to_feats = feats),
             by = "to") %>% 
    select(-rhymes, -poem_id, -pos)

glimpse(rhymes_1835_t)
```

Merge with pairs sequencies

```{r}
glimpse(seq_fin)

# reorder columns to match with rhymes_1835_t
seq_fin <- seq_fin %>% select(id, rhyme_pair, 
                              from, to, 
                              from_pos, from_feats,
                              to_pos, to_feats)

rhymes <- rbind(rhymes_1835_t, seq_fin)

rhymes %>% sample_n(10)
nrow(rhymes) # total number of rhymes
length(unique(rhymes$rhyme_pair)) # number of unique rhymes
```

## Reorder rhyme words

```{r, eval = FALSE}
# toy example

v <- c("абрикос кокос", "громопад громад", "кокос абрикос")

# manual reverse of a pair
print("given pair:")
v[3]
# splitting in two
str_split_1(v[3], " ")

# sort
print("sorting result:")
str_sort(str_split_1(v[3], " ")) # this gives a vector of two

# save as list and paste (via sapply) as a rhyme pair:
print("result as a pasted rhyme pair")
sapply(list(str_sort(str_split_1(v[3], " "))), paste0, collapse = " ")


# in a loop:
true_order <- NULL
for (i in 1:length(v)) {
  true_order[i] <- sapply(list(str_sort(str_split_1(v[i], " "))), paste0, collapse = " ")
}

tibble(given = v,
       trues = true_order)
```

```{r}
raw_pairs <- rhymes %>% pull(rhyme_pair) %>% unique() # extract unique pairs

true_order <- NULL # empty var to store results

for (i in 1:length(raw_pairs)) {
  true_order[i] <- sapply(list(
    str_sort( # reorder
      str_split_1( # split by empty space
        raw_pairs[i], " "))),  
    paste0, collapse = " ") # paste reordered 
}

# create a tibble with ordered pairs
ordered <- tibble(rhyme_pair = raw_pairs,
                  true_pair = true_order)

head(ordered)
```

Attach reordered pairs to the main data table

```{r}
rhymes <- rhymes %>% 
  left_join(ordered, by = "rhyme_pair") %>% 
  rename(rhyme_alph = true_pair)

head(rhymes)
print(paste("Number of unique rhymes after reordering:", 
            length(unique(rhymes$rhyme_alph)) ))
```

## Ending type

Extract data as a vector of words for accentuation

```{r, eval=FALSE}
vec <- NULL
vector <- NULL

glimpse(rhymes)

vector <- paste0(unique(c(rhymes$from, rhymes$to)), collapse = "\n")

write_file(vector, file = "../../data/ch5/corpus_1835_rhymewords.txt")
```

Use `scr/00_preprocessing/00_ru_accent_poent.ipynb` to annotate the data with stresses.

Load accented vector of unique rhyme words.

```{r}
vec_acc <- read_file("../../data/ch5/corpus_1835_rhymewords.accented.txt")

rw_acc <- tibble(accented = vec_acc) %>% # create one-cell tibble
  # separate one word = one row
  separate_rows(accented, sep = "\n") %>% 
  
  # create word-id column with no stress 
  mutate(word = str_remove_all(accented, "'")) 
  
rw_acc <- rw_acc %>% 
  # add id columns
   mutate(doc_id = "", 
         row_id = row_number())

head(rw_acc)
```

### extract closure type

Upload function to rewrite letters & ' stress annotation to binary

```{r}
to_binary <- function(df,document="doc_id",text="acc_text") {
  
  vowels <-  c("а", "е","ё", "у", "о", "ю", "я", "и", "ы", "э")
  #cons <- c("б", "в", "г", "д", "ж", "з", "й", "к", "л", "м", "н", "п", "р", "с", "т", "ф", "х", "ц", "ч", "ш", "щ")
  
  syl_pattern = paste(vowels, collapse="|")
  #cons_pattern <- paste(cons, collapse="|")
  
  ## send to lower case, split by lines, add row ids
  unnested <- df %>% mutate(acc_text = str_to_lower(!! sym(text)),
                            acc_text = str_replace_all(acc_text,"ё", "ё'"),
                            acc_text = str_split(acc_text, "\n")) %>%
    unnest(acc_text) %>% 
    mutate(row_id=row_number())
  
  
  binarized <- unnested %>%
    # replace all vowels with 0 and extract only 0 and 0' patterns
    mutate(stress_pattern = str_replace_all(acc_text, syl_pattern,"0"),
           stress_pattern = str_extract_all(stress_pattern, "0|'")) %>% 
    # unnest extracted lists
    unnest(stress_pattern) %>% 
    group_by(row_id, !! sym(document)) %>% 
    # join back by row
    summarise(stress_pattern=paste(stress_pattern, collapse="")) %>% 
    mutate(stress_pattern = str_replace_all(stress_pattern, "0'", "1"))
  
  return(binarized)
}
```

Apply function & binarise

```{r}
# quick test

to_binary(rw_acc[1:10,], text = "accented") %>% 
  ungroup() %>% 
  select(-doc_id) %>% 
  left_join(rw_acc %>% select(-doc_id), by = "row_id") %>% 
  mutate(closure_pattern = str_replace_all(stress_pattern, "^.*?(1)(0)?(0)?$", "\\1\\2\\3"),
         closure_pattern = ifelse(closure_pattern == 0, 1, closure_pattern),
         closure = ifelse(closure_pattern == "10", "fem", ""),
         closure = ifelse(closure_pattern == "1", "masc", closure),
         closure = ifelse(closure_pattern == "100", "dactylic", closure)) %>% 
  select(accented, word, stress_pattern, closure, closure_pattern)
```

```{r}
words_stressed <- to_binary(rw_acc, text = "accented") %>% 
  ungroup() %>% 
  select(-doc_id) %>% 
  left_join(rw_acc %>% select(-doc_id), by = "row_id") %>% 
  mutate(closure_pattern = str_replace_all(stress_pattern, "^.*?(1)(0)?(0)?$", "\\1\\2\\3"),
         closure_pattern = ifelse(closure_pattern == 0, 1, closure_pattern),
         closure = ifelse(closure_pattern == "10", "fem", ""),
         closure = ifelse(closure_pattern == "1", "masc", closure),
         closure = ifelse(closure_pattern == "100", "dactylic", closure)) %>% 
  select(accented, word, stress_pattern, closure, closure_pattern)

head(words_stressed)
rm(rw_acc)
```

Attach closure data to rhymes

nb: this code result in redubplication, need to check (now just add distinct in the end)

```{r}
rhymes_end <- rhymes %>% 
  # attach closure features to 'from' word
  left_join(words_stressed %>% 
              select(word, closure, closure_pattern) %>% 
              rename(from = word,
                     from_closure = closure,
                     from_closure_pattern = closure_pattern),
            by = "from") %>% 
  
  # attach closure features to 'to' word
  left_join(words_stressed %>% 
              select(word, closure, closure_pattern) %>% 
              rename(to = word,
                     to_closure = closure,
                     to_closure_pattern = closure_pattern),
            by = "to") %>% 
  distinct()

head(rhymes_end)

nrow(rhymes)
nrow(rhymes_end)
```

Save

```{r, eval=FALSE}
write.csv(file = "../../data/ch5/rhymes_parsed_closure.csv", rhymes_end)
write.csv(file = "../../data/ch5/rhymes_parsed.csv", rhymes)
```

## Rhymer data

old code

```{r}
rhymer <- read_file("data/rhymer.txt")

rhymer <- tibble(word = rhymer) %>% 
  separate_rows(word, sep = "\n") %>% 
  filter(word != "")

nrow(rhymer) # 1000 !
```

```{r}
head(rhymer)
```

```{r}
# real top of the words on these endings
rnc %>% select(rhyme, year) %>% 
  separate(rhyme, c("from", "to"), sep = " ") %>% 
  pivot_longer(!year, names_to = "group", values_to = "word") %>% 
  count(word, sort = T) %>% 
  mutate(ending = str_extract(word, "\\w{2}$")) %>% 
  filter(ending %in% c("ба", "ва", "га")) #%>% 
```

```{r}
 #inner_join(rhymer, by = "word")

rnc %>% select(rhyme, year) %>% 
  separate(rhyme, c("from", "to"), sep = " ") %>% 
  pivot_longer(!year, names_to = "group", values_to = "word") %>% 
  count(word, sort = T) %>% 
  mutate(ending = str_extract(word, "\\w{2}$")) %>% 
  filter(ending %in% c("ба", "ва", "га")) %>% 
  mutate(rank = row_number()) %>% 
  inner_join(rhymer, by = "word")

# 305 words are intersected with the rhymer
```

```{r}
# 130
archive_rhymes %>% select(rhyme, year) %>% 
  separate(rhyme, c("from", "to"), sep = " ") %>% 
  pivot_longer(!year, names_to = "group", values_to = "word") %>% 
  count(word, sort = T) %>% 
  mutate(ending = str_extract(word, "\\w{2}$")) %>% 
  filter(ending %in% c("ба", "ва", "га")) #%>% 
```

```{r}
#inner_join(rhymer, by = "word")

archive_rhymes %>% select(rhyme, year) %>% 
  separate(rhyme, c("from", "to"), sep = " ") %>% 
  pivot_longer(!year, names_to = "group", values_to = "word") %>% 
  count(word, sort = T) %>% 
  mutate(ending = str_extract(word, "\\w{2}$")) %>% 
  filter(ending %in% c("ба", "ва", "га")) %>% 
  mutate(rank = row_number()) %>% 
  inner_join(rhymer, by = "word")

# 108 words are intersected with the rhymer
```
